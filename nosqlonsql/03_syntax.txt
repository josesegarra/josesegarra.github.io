

[markdown]
# Statement syntax

NoSqlOnSql statements can be intermixed with normal TSQL statements, the following rules apply:

- **NoSqlOnSql statements** begin with the keyword <span style="color:blue;font-size:15px">nosql</span>
- **Comments**  follow the same rules as TSQL comments: <span style="color:blue">/* BLOCK COMMENTS */</span> and <span style="color:blue">\-\- LINE COMMENTS</span>.

## Statements

Similarly to SQL, NoSqlOnSql uses statements to perform actions on the data. There are three kind of statements:

- Definition statements: used to create NoSqlOnSql structures able to host NoSqlOnSql data. These statements are equivalent to DDL statements in SQL.
- Data manipulation statements: used to manage data in NoSqlOnSql structures. These statements are equivalent to DML statements in SQL.
- Meta Data statements: used to fetch information (audit, integrity,...) about data stored in NoSqlOnSql structures. The equivalent for this would be the system tables in SQL. 

NoSqlOnSql statements can communicate with SQL statements in two different ways:

- The <span style="color:blue;font-size:15px">nosql select</span> statement produces a SQL result that can be used directly on other SQL statements.
- Using SQL variables:
    * NoSqlOnSql statements can create and assign values to existing SQL variables. These SQL variables can be used by SQL statements.
    * NoSqlOnSql statements can use existing SQL variables as normal NoSqlOnSql values. 

## Values

Similar to SQL or JSON, NoSqlOnSql is a **typed** language. Every value appearing in a NoSqlOnSql statement needs to have a type known at compile time. 

Due to the absence of an underlying entity model, the only way of knowing the type of a value is by inspecting its declaration on the statement where the value is used. For literal values, this is 
done implicitly by their syntax (strings are surrounded by quotes, real numbers have a decimal point, ....), for not literal values (data retrieval, SQL functions, SQL variables,...) we need to prefix the 
value with a type prefix. There are 4 **type prefixes**: 

- <span style="color:blue">$</span> indicates that the value is a string
- <span style="color:blue">#</span> indicates that the value is an integer
- <span style="color:blue">%</span> indicates that the value is a real
- <span style="color:blue">^</span> indicates that the value is a document (object or array)

These prefixes ensure that the value belongs to the specified type or force a cast to it. 

Values in an object are located by the name of the property they belong, property names can be nested using the <span style="color:blue">. <span style="font-style: italic;font-size:10px">(dot)</span></span>. Values in 
an array are located by its position using the <span style="color:blue">[position]<span style="font-style: italic;font-size:10px">(brackets)</span></span> syntax. 


## Elements of a statement

A statement is made of:

- keywords defining the type and structure of the statement: *select* + *from* + *where*, *insert*+*into*, ..

- semantic define domain specific information, they can be of two types **names of universes** and **names of properties for objects*

- values to be assigned to objects and/or properties. There are four kinds of "values":
    - **literals** they are objects, strings, integer or real numbers. The type is infered from the syntax value.
	- **document values** values stored in NoSqlOnSql and coming from a document. Within the statement, the type must be indicated using one of the **type prefixes**.
	- **SQL values** they are values originated at the SQL level, they can be of 2 different types:
        * values coming from a SQL expressions (ie: <span style="color:blue">GETDATE()</span>) they must be enclosed in parenthesis and casted to a NoSqlOnSqlType using a type prefix.
        * values coming from a SQL variable, they always start with the <span style="color:blue">@</span> prefix. If the SQL variable has been generated by a NoSqlOnSql statement, then the type is already known by the transpiler. If the SQL variable has been defined outside of NoSqlOnSql then it must be casted or fall into the SQL boxing rules. 
    - **reserved symbols** they are only available for some kind of statements, they might be:
        * IDENTITY symbol <span style="color:blue">?</span>, used in Data Manipulation Statements, it is always of type **object** and has the value of the current document in the statement
	    * ANY INDEX symbol <span style="color:blue">*</span>, used in Data Manipulation Statements in array expressions, it is always of type **int** and has the value of the any valid position element in the array

## Sample

The code below is a valid NoSqlOnSql script, mixing NoSql and SQL statements. Do not worry if you don't fully understand the details, the point right now 
is to notice how SQL statements and NoSqlOnSql statements can be combined, and how values are typed.


[/markdown]
[code]
nosql create springfield override                                       -- Create a new universe called SpringField, delete any previous data on the universe
    
nosql insert new object @NedId={Name: 'Ned'}                            -- Create Ned and get a SQL reference @NedId to it
        into springfield                                                -- Ned is created in universe Springfield

nosql update $Lastname='Flanders' in springfield  where ?=@NedId        -- Set Flanders as Lastname for Ned
nosql update ^Spouse={                                                  -- Let's assign a SPOUSE
        Name:'Maude'                                                    --      Named "Maude Flanders" 
        ,Lastname:'Flanders'
        ,Spouse: ^(@NedId)                                              --      whos spouse is Ned
        ,Children:[                                                     --      notice that Maude has two Children
             {Name:'Todd',Lastname:'Flanders'}                          --      Named Todd & Rod. Notice that Rod has no LastName
			,{Name:'Rod'}                                               --      Todd & Ron are not yet Children of Ned
        ]                     
    } in springfield  where ?=@NedId                                    -- TO NedId in universe Springfield
        
declare @children int                                                   -- TSQL variables can receive NOSQL values
nosql select @children=^Children from springfield  where $Name='Maude'  -- Get a reference to the children of Maude
nosql update ^Children=@children in springfield  where $Name='Ned'      -- And set them as the childrens of Ned
    
DROP VIEW IF EXISTS [FLANDERS];                                         -- Let's DROP any SQL view we might have named Flanders. This is a normal SQL statement

nosql go                                                                -- CREATE VIEW requires its own batch, so we CLOSE BATCH #0 with data returned
CREATE VIEW [FLANDERS]                                                  -- Let's create a VIEW with   
AS nosql select $Name,$LastName,$Children[0].Name as FirstChild         -- All documents in universe Springfield having an attribute 'Flanders'
            from springfield where $LastName='Flanders'

nosql go                                                                -- We close BATCH #1 to force the creation of the view, again no data has yet been fetched
select * from Flanders                                                  -- View all the Flanders...but we didn't assign a LastName to Rod
nosql update $LastName='Flanders' in springfield where $name='Rod'      -- Let's fix it
select * from Flanders                                                  -- Now our list of Flanders is correct

[/code]

[markdown]
This script can be compiled by the NoSqlOnSql transpiler, and executed directly by Sql Server producing RESULT 1: 
[/markdown]
[data]
           |name       |lastname   |firstchild
           |---------- |---------- |----------
 1         |Ned        |Flanders   |Todd
 2         |Maude      |Flanders   |Todd
 3         |Todd       |Flanders   |null
[/data]
[markdown]
And RESULT 2: 
[/markdown]
[data]
           |name       |lastname   |firstchild
           |---------- |---------- |----------
 1         |Ned        |Flanders   |Todd
 2         |Maude      |Flanders   |Todd
 3         |Todd       |Flanders   |null
 4         |Rod        |Flanders   |null
[/data]
